   1 | import sys
   2 | try:
   3 |     import bpy
   4 |     import math
   5 |     import mathutils
   6 |     import os
   7 |     import sys
   8 |     import functools
   9 |     import collections
  10 |     from mathutils import Vector, Matrix
  11 |     try:
  12 |         import numpy as np
  13 |     except:
  14 |         np = None
  15 |     
  16 |     Light = collections.namedtuple("Light", ["location", "target", "size", "strength", "view_angle"])
  17 |     
  18 |     input_eye_target = Vector([0.0, -14.0, 0.0])
  19 |     input_eye_cornea_refrative_index = 1.336
  20 |     input_cam_target = Vector([0, -14, 0])
  21 |     input_pupil_radius = 2.0
  22 |     input_eye_radius = 14
  23 |     input_eye_pos = Vector([0, 0, 0])
  24 |     input_cam_focus_distance = 46.0
  25 |     input_eye_up = Vector([0, 0, 1])
  26 |     input_cam_fstop = 2.0
  27 |     input_lights = [Light(view_angle = 45,strength = 2,size = 2,location = Vector([0, -60.0, 0]),target = Vector([0, -14, 0]))]
  28 |     input_cam_pos = Vector([0, -60.0, 0])
  29 |     input_cam_image_size = [640,480]
  30 |     input_cam_up = Vector([0, 0, 1])
  31 |     output_params_path = None
  32 |     output_render_path = '/Users/aguirre/Desktop/Blender_Simulate01/reconstructedFrame00005.png'
  33 |     input_render_samples = 7
  34 |     input_eye_closedness = 0.0
  35 |     input_cam_focal_length = 772.548339959
  36 |     
  37 |     scene = bpy.context.scene
  38 |     armature = bpy.data.objects['Armature Head']
  39 |     camera_obj = bpy.data.objects['Camera']
  40 |     camera = bpy.data.cameras['Camera']
  41 |     
  42 |     eyeL = bpy.data.objects['eye.L']
  43 |     
  44 |     eyeLbone = armature.pose.bones['def_eye.L']
  45 |     pupilLbone = armature.pose.bones['eyepulpex.L']
  46 |     eyeLblinkbone = armature.pose.bones['eyeblink.L']
  47 |     eyeRbone = armature.pose.bones['def_eye.R']
  48 |     pupilRbone = armature.pose.bones['eyepulpex.R']
  49 |     eyeRblinkbone = armature.pose.bones['eyeblink.R']
  50 |     
  51 |     cornea_material = bpy.data.materials['eye cornea']
  52 |     
  53 |     armature_matrix = armature.matrix_world
  54 |     
  55 |     scene.frame_current = 0
  56 |     scene.frame_start = 0
  57 |     scene.frame_end = 0
  58 |     
  59 |     # Get world eye radius and centre
  60 |     # All other locations are translated/scaled to be relative to these
  61 |     eye_radius = eyeLbone.bone.length
  62 |     eye_centre = armature_matrix*eyeLbone.head
  63 |     
  64 |     def input_to_world(val):
  65 |         scale = eye_radius/input_eye_radius
  66 |         if isinstance(val, Vector):
  67 |             return (val - input_eye_pos) * scale + eye_centre
  68 |         else:
  69 |             return val*scale
  70 |     
  71 |     def world_to_input(val):
  72 |         scale = eye_radius/input_eye_radius
  73 |         if isinstance(val, Vector):
  74 |             return (val - eye_centre) / scale + input_eye_pos
  75 |         else:
  76 |             return val/scale
  77 |     
  78 |     def look_at_mat(target, up, pos):
  79 |         zaxis = (target - pos).normalized()
  80 |         xaxis = up.cross(zaxis).normalized()
  81 |         yaxis = zaxis.cross(xaxis).normalized()
  82 |         return Matrix([xaxis, yaxis, zaxis]).transposed()
  83 |     
  84 |     def look_at(obj, target, up, pos, initPoseMat):
  85 |         if isinstance(obj, bpy.types.PoseBone):
  86 |             pos = armature_matrix * obj.head
  87 |         else:
  88 |             pos = obj.location
  89 |     
  90 |         obj_rot_mat = look_at_mat(target,up,pos) * initPoseMat
  91 |         #obj_rot_mat = initPoseMat
  92 |     
  93 |         if obj.parent:
  94 |             P = obj.parent.matrix.decompose()[1].to_matrix()
  95 |             obj_rot_mat = P * obj_rot_mat * P.inverted()
  96 |     
  97 |         obj.rotation_mode = 'QUATERNION'
  98 |         obj.rotation_quaternion = obj_rot_mat.to_quaternion()
  99 |     
 100 |     corneaGroup = eyeL.vertex_groups['eyecornea.L']
 101 |     corneaVertices = [v for v in eyeL.data.vertices if corneaGroup.index in [g.group for g in v.groups]]
 102 |     
 103 |     def fitsphere(points):
 104 |         n = len(points)
 105 |         points = np.asarray(points)
 106 |         centroid = np.mean(points, axis=0)
 107 |     
 108 |         points = points - centroid
 109 |         sqmag = [[sum(x*x for x in p)] for p in points]
 110 |     
 111 |         Z = np.bmat([sqmag, points, np.ones((n,1))])
 112 |     
 113 |         M = Z.T * Z / n
 114 |     
 115 |         R = np.ravel(np.asarray(M[-1,:]))
 116 |         N = np.eye(len(R), dtype=points.dtype)
 117 |         N[:,0] = 4*R
 118 |         N[0,:] = 4*R
 119 |         N[0,0] = 8*R[0]
 120 |         N[-1,0] = 2
 121 |         N[0,-1] = 2
 122 |         N[-1,-1] = 0
 123 |     
 124 |         # M A = mu N A = N mu A
 125 |         # inv(N)M A = mu A
 126 |         mu,E = np.linalg.eig(np.linalg.inv(N)*M);
 127 |         idx = np.argsort(mu);
 128 |         A = E[:,idx[1]];
 129 |     
 130 |         A = np.ravel(np.asarray(A))
 131 |     
 132 |         return (-A[1:-1]/A[0]/2 + centroid,
 133 |                   math.sqrt((sum(a*a for a in A[1:-1]) - 4*A[0]*A[-1]))/abs(A[0])/2)
 134 |     
 135 |     if np:
 136 |         eye_cornea_centre, eye_cornea_radius = fitsphere([tuple(v.co) for v in corneaVertices])
 137 |         eye_cornea_centre = Vector(eye_cornea_centre)
 138 |         cornea_centre = eyeL.matrix_local * eye_cornea_centre
 139 |         cornea_radius = (eyeL.matrix_local * (eye_cornea_centre+Vector((eye_cornea_radius,0,0))) - cornea_centre).length
 140 |     else:
 141 |         # If the user doesn't have numpy, don't dynamically calculate cornea params, just use hardcoded
 142 |         cornea_centre = input_to_world(Vector([-0.016783643513917923, -5.577363014221191, 0.04836755618453026]))
 143 |         cornea_radius = input_to_world(7.922206814944914)
 144 |         print("WARNING: Blender's python installation doesn't have numpy, using hardcoded cornea parameters")
 145 |     
 146 |     
 147 |     for obj in list(bpy.data.objects):
 148 |         if obj.type == 'LAMP':
 149 |             scene.objects.unlink(obj)
 150 |             bpy.data.objects.remove(obj)
 151 |     
 152 |     # Add lights
 153 |     for i,light in enumerate(input_lights):
 154 |         # Create new lamp datablock
 155 |         lamp_data = bpy.data.lamps.new(name="Lamp.{}".format(i), type='SPOT')
 156 |     
 157 |         # Create new object with our lamp datablock
 158 |         lamp_object = bpy.data.objects.new(name="Lamp.{}".format(i), object_data=lamp_data)
 159 |     
 160 |         # Link lamp object to the scene so it'll appear in this scene
 161 |         scene.objects.link(lamp_object)
 162 |     
 163 |         lamp_data.use_nodes = True
 164 |     
 165 |         lamp_object.location = input_to_world(light.location)
 166 |         look_at(lamp_object,
 167 |                 input_to_world(light.target),
 168 |                 input_to_world(input_cam_up) - input_to_world(Vector([0,0,0])),
 169 |                 light.location,
 170 |                 Matrix([[-1, 0, 0],
 171 |                         [ 0, 1, 0],
 172 |                         [ 0, 0,-1]]))
 173 |         lamp_data.shadow_soft_size = input_to_world(light.size)
 174 |         lamp_data.spot_size = light.view_angle*math.pi/180
 175 |         lamp_data.spot_blend = 1.0
 176 |         lamp_data.node_tree.nodes['Emission'].inputs['Strength'].default_value = light.strength
 177 |         lamp_data.cycles.use_multiple_importance_sample = True
 178 |         lamp_data.show_cone = True
 179 |     
 180 |     # Remove eye IK constraint
 181 |     for c in list(eyeLbone.constraints.values()):
 182 |         eyeLbone.constraints.remove(c)
 183 |     for c in list(eyeRbone.constraints.values()):
 184 |         eyeRbone.constraints.remove(c)
 185 |     
 186 |     # Set eye target
 187 |     look_at(eyeLbone,
 188 |             input_to_world(input_eye_target),
 189 |             (input_to_world(input_eye_up) - input_to_world(Vector([0,0,0]))),
 190 |             eye_centre,
 191 |             Matrix([[ 1, 0, 0],
 192 |                     [ 0, 0, 1],
 193 |                     [ 0,-1, 0]]))
 194 |     look_at(eyeRbone,
 195 |             input_to_world(input_eye_target),
 196 |             (input_to_world(input_eye_up) - input_to_world(Vector([0,0,0]))),
 197 |             eye_centre,
 198 |             Matrix([[ 1, 0, 0],
 199 |                     [ 0, 0, 1],
 200 |                     [ 0,-1, 0]]))
 201 |     
 202 |     # Set eye blink location
 203 |     eyeLblinkbone.location[2] = input_eye_closedness * eyeLblinkbone.constraints['Limit Location'].max_z
 204 |     eyeRblinkbone.location[2] = input_eye_closedness * eyeRblinkbone.constraints['Limit Location'].max_z
 205 |     
 206 |     
 207 |     # Calculate base pupil diameter by finding mean distance of pupil vertex to pupil vertex centroid
 208 |     pupilGroup = eyeL.vertex_groups['eyepulpex.L']
 209 |     pupilVertices = [eyeL.matrix_local * v.co for v in eyeL.data.vertices if pupilGroup.index in [g.group for g in v.groups]]
 210 |     pupilVertexCentre = functools.reduce(lambda x,y: x+y, pupilVertices)/len(pupilVertices)
 211 |     pupil_base_radius = sum((v-pupilVertexCentre).length for v in pupilVertices)/len(pupilVertices)
 212 |     # Set pupil scale
 213 |     pupil_scale = input_to_world(input_pupil_radius) / pupil_base_radius
 214 |     if pupil_scale < pupilLbone.constraints["Limit Scaling"].min_x:
 215 |         raise RuntimeError("Pupil size {} is too small. Minimum size is {}".format(
 216 |                             input_pupil_radius,
 217 |                             world_to_input(pupilLbone.constraints["Limit Scaling"].min_x * pupil_base_radius)))
 218 |     if pupil_scale > pupilLbone.constraints["Limit Scaling"].max_x:
 219 |         raise RuntimeError("Pupil size {} is too large. Maximum size is {}".format(
 220 |                             input_pupil_radius,
 221 |                             world_to_input(pupilLbone.constraints["Limit Scaling"].max_x * pupil_base_radius)))
 222 |     pupilLbone.scale = Vector([pupil_scale,1,pupil_scale])
 223 |     pupilRbone.scale = Vector([pupil_scale,1,pupil_scale])
 224 |     
 225 |     
 226 |     # Calculate iris radius by finding mean distance of iris vertex to iris vertex centroid
 227 |     irisGroup = eyeL.vertex_groups['eyeiris.L']
 228 |     irisVertices = [eyeL.matrix_local * v.co for v in eyeL.data.vertices if irisGroup.index in [g.group for g in v.groups]]
 229 |     irisVertexCentre = functools.reduce(lambda x,y: x+y, irisVertices)/len(irisVertices)
 230 |     iris_radius = sum((v-irisVertexCentre).length for v in irisVertices)/len(irisVertices)
 231 |     
 232 |     cornea_material.node_tree.nodes['TrickyGlass'].inputs[
 233 |         cornea_material.node_tree.nodes['TrickyGlass'].inputs.find('IOR') # workaround for blender bug
 234 |     ].default_value = input_eye_cornea_refrative_index
 235 |     
 236 |     # Set camera location
 237 |     camera_obj.location = input_to_world(input_cam_pos)
 238 |     # Set camera target
 239 |     look_at(camera_obj,
 240 |             input_to_world(input_cam_target),
 241 |             input_to_world(input_cam_up) - input_to_world(Vector([0,0,0])),
 242 |             camera_obj.location,
 243 |             Matrix([[-1, 0, 0],
 244 |                     [ 0, 1, 0],
 245 |                     [ 0, 0,-1]]))
 246 |     
 247 |     scene.render.resolution_x = input_cam_image_size[0]
 248 |     scene.render.resolution_y = input_cam_image_size[1]
 249 |     
 250 |     camera.sensor_width = 35.
 251 |     camera.sensor_height = camera.sensor_width*input_cam_image_size[1]/input_cam_image_size[0]
 252 |     camera.lens_unit = 'MILLIMETERS'
 253 |     camera.lens = camera.sensor_width * input_cam_focal_length / input_cam_image_size[0]
 254 |     camera.dof_distance = input_to_world(input_cam_focus_distance)
 255 |     camera.cycles.aperture_fstop = input_cam_fstop
 256 |     
 257 |     scene.cycles.aa_samples = input_render_samples
 258 |     
 259 |     scene.update()
 260 |     
 261 |     # Use CUDA if possible
 262 |     try:
 263 |         bpy.context.user_preferences.system.compute_device_type = 'CUDA'
 264 |     except:
 265 |         pass
 266 |     
 267 |     if output_params_path:
 268 |         def mlabVec(vec):
 269 |             return "[{}]".format(", ".join(str(x) for x in vec))
 270 |         def mlabMat(mat):
 271 |             return "[{}]".format(";".join(mlabVec(x) for x in mat))
 272 |     
 273 |         # Get actual pupil vertex positions by applying modifiers to eye mesh
 274 |         eyeL_mesh = eyeL.to_mesh(scene, True, 'RENDER')
 275 |         def isPupil(vertex):
 276 |             for g in vertex.groups:
 277 |                 if g.group == pupilGroup.index and g.weight == 1.0:
 278 |                     return True
 279 |     
 280 |         pupilRealVertices = [eyeL.matrix_local * v.co for v in eyeL_mesh.vertices if isPupil(v)]
 281 |     
 282 |         with open(output_params_path, "w") as params_file:
 283 |             lines = [
 284 |                 "eye_pos = {};".format(mlabVec(input_eye_pos)),
 285 |                 "eye_target = {};".format(mlabVec(input_eye_target)),
 286 |                 "eye_radius = {};".format(input_eye_radius),
 287 |                 "cornea_centre = {};".format(mlabVec(world_to_input(cornea_centre))),
 288 |                 "cornea_radius = {};".format(world_to_input(cornea_radius)),
 289 |                 "iris_radius = {};".format(world_to_input(iris_radius)),
 290 |                 "pupil_centre = {};".format(mlabVec(world_to_input(armature_matrix * eyeLbone.tail))),
 291 |                 "pupil_radius = {};".format(input_pupil_radius),
 292 |                 "",
 293 |                 "eye_matrix = {};".format(mlabMat(look_at_mat(pos=input_eye_pos,
 294 |                                                        target=input_eye_target,
 295 |                                                        up=input_eye_up)*Matrix([[-1, 0, 0],[ 0, 1, 0],[ 0, 0,-1]]))),
 296 |                 "eye = eye_make(cornea_radius, eye_matrix);",
 297 |                 "eye.pos_cornea = [cornea_centre(1) -cornea_centre(3) cornea_centre(2) 1]';",
 298 |                 "eye.depth_cornea = cornea_radius - sqrt(cornea_radius^2 - iris_radius^2);",
 299 |                 "eye.n_cornea = {};".format(input_eye_cornea_refrative_index),
 300 |                 "eye.pos_apex = eye.pos_cornea + [0 0 -cornea_radius 0]';",
 301 |                 "eye.pos_pupil = [eye_matrix \ pupil_centre' ; 1];",
 302 |                 "eye.across_pupil = [pupil_radius 0 0 0]';",
 303 |                 "eye.up_pupil = [0 pupil_radius 0 0]';",
 304 |                 "",
 305 |                 "camera_pos = {};".format(mlabVec(input_cam_pos)),
 306 |                 "camera_target = {};".format(mlabVec(input_cam_target)),
 307 |                 "",
 308 |                 "camera_matrix = {};".format(mlabMat(look_at_mat(pos=input_cam_pos,
 309 |                                                        target=input_cam_target,
 310 |                                                        up=input_cam_up)*Matrix([[-1, 0, 0],[ 0, 1, 0],[ 0, 0,-1]]))),
 311 |                 "camera = camera_make();",
 312 |                 "camera.trans = [camera_matrix camera_pos' ; 0 0 0 1];",
 313 |                 "camera.rest_trans = camera.trans;",
 314 |                 "camera.focal_length = {};".format(input_cam_focal_length),
 315 |                 "camera.resolution = [{} {}];".format(*input_cam_image_size),
 316 |                 "",
 317 |             ]
 318 |             for i,light in enumerate(input_lights):
 319 |                 lines += [
 320 |                     "light{} = light_make();".format(i),
 321 |                     "light{}.pos = [{} 1]';".format(i, mlabVec(light.location)),
 322 |                     "cr{i} = eye_find_cr(eye, light{i}, camera);".format(i=i),
 323 |                     "",
 324 |                 ]
 325 |             lines += [
 326 |                 "pupil_vertices = [ " + ";".join(" ".join(str(x) for x in world_to_input(v)) + " 1" for v in pupilRealVertices) + "]';"
 327 |                 "",
 328 |             ]
 329 |             lines += [
 330 |                 "figure(1)",
 331 |                 "clf;",
 332 |                 "hold on;",
 333 |                 "eye_draw(eye);",
 334 |                 "plot3([eye_pos(1)], [eye_pos(2)], [eye_pos(3)], 'bx');",
 335 |                 "trans_cornea_centre = eye_matrix * eye.pos_cornea(1:3);",
 336 |                 "plot3([trans_cornea_centre(1)], [trans_cornea_centre(2)], [trans_cornea_centre(3)], 'gx');",
 337 |                 "trans_pupil_centre = eye_matrix * eye.pos_pupil(1:3);",
 338 |                 "plot3([trans_pupil_centre(1)], [trans_pupil_centre(2)], [trans_pupil_centre(3)], 'rx');",
 339 |                 "pupil_circle = eye_get_pupil(eye);",
 340 |                 "pupil_circle = [pupil_circle pupil_circle(:,1)];",
 341 |                 "plot3(pupil_circle(1,:), pupil_circle(2,:), pupil_circle(3,:), 'm-');",
 342 |                 "eye_target_short = 2 * eye_radius * eye_target / norm(eye_target);",
 343 |                 "plot3([eye_pos(1) eye_target_short(1)], [eye_pos(2) eye_target_short(2)], [eye_pos(3) eye_target_short(3)], 'b--');",
 344 |                 "",
 345 |                 "plot3(camera.trans(1,4), camera.trans(2,4), camera.trans(3,4), 'k*');",
 346 |                 "",
 347 |                 "up=[0 5 0 1]';",
 348 |                 "across=[10 0 0 1]';",
 349 |                 "in=[0 0 -5 1]';",
 350 |                 "trans_up = camera.trans*up;",
 351 |                 "trans_across = camera.trans*across;",
 352 |                 "trans_in = camera.trans*in;",
 353 |                 "plot3([camera.trans(1,4) trans_up(1)], [camera.trans(2,4) trans_up(2)], [camera.trans(3,4) trans_up(3)], 'k-');",
 354 |                 "plot3([camera.trans(1,4) trans_across(1)], [camera.trans(2,4) trans_across(2)], [camera.trans(3,4) trans_across(3)], 'k-');",
 355 |                 "plot3([camera.trans(1,4) trans_in(1)], [camera.trans(2,4) trans_in(2)], [camera.trans(3,4) trans_in(3)], 'k:');",
 356 |                 "",
 357 |             ]
 358 |             for i,light in enumerate(input_lights):
 359 |                 lines += [
 360 |                     "light_draw(light{i});".format(i=i),
 361 |                     "if ~isempty(cr{i})".format(i=i),
 362 |                     "    plot3(cr{i}(1), cr{i}(2), cr{i}(3), 'xr');".format(i=i),
 363 |                     "end",
 364 |                 ]
 365 |             lines += [
 366 |                 "",
 367 |                 "hold off;",
 368 |                 "axis equal;",
 369 |                 "xlim auto;",
 370 |                 "ylim auto;",
 371 |                 "zlim auto;",
 372 |                 "view(45, 2*eye_radius);",
 373 |                 "",
 374 |             ]
 375 |             lines += [
 376 |                 "figure(2);",
 377 |                 "clf;",
 378 |                 "I = imread('{}');".format(output_render_path),
 379 |                 "imshow(I);",
 380 |                 "hold on;",
 381 |                 "pupil_refracted_vertices = zeros(4,0);",
 382 |                 "for i=1:size(pupil_vertices, 2)",
 383 |                 "    img=eye_find_refraction(eye, camera.trans(:,4), pupil_vertices(:,i));",
 384 |                 "    if ~isempty(img)",
 385 |                 "        pupil_refracted_vertices(:,end+1)=img;",
 386 |                 "    end",
 387 |                 "end",
 388 |                 "pupil_points = camera_project(camera, pupil_refracted_vertices);",
 389 |                 "pupil_points = pupil_points(:, convhull(pupil_points'));",
 390 |                 "plot(camera.resolution(1)/2 + pupil_points(1,:), camera.resolution(2)/2 - pupil_points(2,:), '-m', 'LineWidth', 1.5);",
 391 |             ]
 392 |             for i,light in enumerate(input_lights):
 393 |                 lines += [
 394 |                     "if ~isempty(cr{i})".format(i=i),
 395 |                     "    pcr = camera_project(camera, cr{i});".format(i=i),
 396 |                     "    plot(camera.resolution(1)/2 + pcr(1), camera.resolution(2)/2 - pcr(2), 'xr', 'LineWidth', 1.5, 'MarkerSize', 15);".format(i=i),
 397 |                     "end",
 398 |                 ]
 399 |             lines += [
 400 |                 "hold off;"
 401 |             ]
 402 |             params_file.write("\n".join(lines))
 403 |             #params_file.write("pupil centre = {}\n".format(strVec(world_to_input(armature_matrix * eyeLbone.tail))))
 404 |             #    " centre = {}\n".format(strVec(world_to_input(eye_centre))))
 405 |             #params_file.write("eye centre = {}\n".format(strVec(world_to_input(eye_centre))))
 406 |             #params_file.write("eye radius = {}\n".format(world_to_input(eye_radius)))
 407 |             #params_file.write("eye target = {}\n".format(strVec(input_eye_target)))
 408 |             #params_file.write("eye up = {}\n".format(strVec(input_eye_up)))
 409 |             #params_file.write("eye closedness = {}\n".format(input_eye_closedness))
 410 |             #params_file.write("cornea centre = {}\n".format(strVec(world_to_input(cornea_centre))))
 411 |             #params_file.write("cornea radius = {}\n".format(world_to_input(cornea_radius)))
 412 |             #params_file.write("cornea refractive index = {}\n".format(input_eye_cornea_refrative_index))
 413 |             #params_file.write("pupil centre = {}\n".format(strVec(world_to_input(armature_matrix * eyeLbone.tail))))
 414 |             #params_file.write("pupil radius = {}\n".format(world_to_input(pupilLbone.scale.x * pupil_base_radius)))
 415 |             #params_file.write("iris radius = {}\n".format(world_to_input(iris_base_radius)))
 416 |             #params_file.write("camera position = {}\n".format(strVec(world_to_input(camera_obj.location))))
 417 |             #params_file.write("camera target = {}\n".format(strVec(input_cam_target)))
 418 |             #params_file.write("camera up = {}\n".format(strVec(input_cam_up)))
 419 |             #params_file.write("camera focal length = {}\n".format(input_cam_focal_length))
 420 |             #params_file.write("camera focus distance = {}\n".format(input_cam_focus_distance))
 421 |             #params_file.write("camera fstop = {}\n".format(input_cam_fstop))
 422 |             #params_file.write("image size = {}\n".format(tuple(input_cam_image_size)))
 423 |     
 424 | except:
 425 |     import traceback
 426 |     with open('blender_err.log','a') as f:
 427 |         f.write('\n'.join(traceback.format_exception(*sys.exc_info())))
 428 |     sys.exit(1)
------
